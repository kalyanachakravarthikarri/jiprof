<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		
	</head>
	
	<body>
		<table border="0">
			<tr>
				<td rowspan=2">
					<img src="images/jip-logo-150.png"/>&nbsp;
				</td>
				<td rowspan="2">
					<h1>JIP &#8212 The Java Interactive Profiler</h1>
				</td>
				<td valign="bottom">&nbsp;
					<a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=148701&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></a>			
				</td>
			</tr>
			<tr>
				<td valign="top">&nbsp;
					<a href="http://www.java.net"><img src="images/javanet_button_170.gif"/></a>			
				</td>
			</tr>
			
		</table>
		<hr/>

		<h2>What is JIP?</h2>
		<a href="http://sourceforge.net/projects/jiprof/">JIP</a> is a code profiling tool much like the <code>hprof</code> tool
		that ships with the JDK. There are, however, a few differences:
		<ol>
			<li><b>Interactivity.</b> <code>hprof</code> is not an interactive
			profiler. It starts when your program starts and ends when the 
			JVM exits. In many cases this doesn't give you a true 
			measure of performance since the Just In Time compiler doesn't
			compile code on the first pass. In addition, this type of profiler
			is not useable at all in web applications since you end up
			profiling the web container as well as the web application.
			JIP, on the other hand, allows you to turn the profiler
			on and off while the JVM is running.</li>
			
			<li><b>No native code.</b> Most profilers have some native 
			component. This is because most profilers use the 
			<code>JVMPI</code> (Java Virtual Machine Profiling Interface) 
			which requires the use of native components. JIP, however, 
			is pure Java. It takes advantage of the Java5&#153; feature
			which allows you to hook the classloader. JIP adds <a 
			href="http://en.wikipedia.org/wiki/Aspect_oriented">
			aspects</a> to every method of every class that you want
			to profile. These aspects allow it to capture performance
			data.</li>
			
			<li><b>Very low overhead.</b>
			Most profilers are very slow. In many cases <code>hprof</code>
			will cause a program to run 20 times slower. JIP, on the other
			hand, is lightweight. A VM with profiling turned on is about
			twice as slow as one without a profiler. When the profiler
			is turned off, there is almost no overhead associated with
			using JIP.</li>
			
			<li><b>Performance Timings.</b>
			JIP gathers performance data. You cannot use most profilers
			to do timings of your application. <code>hprof</code>, for
			example, will show you the relative amount of time that is 
			spent in different parts of your code, but <code>hprof</code>
			has so much overhead, that you cannot use it to get real
			world timing measurements. JIP, on the other hand, actually
			tracks the amount of time used to gather performance data
			and factors that time out of its analysis. This allows you
			to get close to real world timings for every class in your 
			code. So there is no need to litter your code with 
			<code>System.currentTimeMillis()</code>!</li>
			
			<li><b>Filters by package/class name.</b> One of the annoying
			things about hprof is that there is no way to filter out classes
			by class or package name. JIP allows you to do just that (for more
			information, look at the profile.properties file). This in not to
			say that the execution time is not included. It is included
			but can only be seen in the execution time of the calling 
			routine.</li>
		</ol>
		
		<h2>How to use JIP</h2>
		<br>
		Note: JIP requires a Java5&#153 VM.
		</br>
		<P>
			To run the profiler, you need the following:
			<ul>
				<li><code>profile.jar</code></li>
				<li>A profile properties file (optional)</li>
			</ul>
		</P>
		<p> These files are loaded by the application classloader and
		    should not be in the extentions loader path. The jar files
			need to be in the same directory. The properties file can
			be anywhere.
		</p>
		<p>
			To use the profiler, you need to use the following JVM arguments:
			<pre><code>
-javaagent:[DIR]\profile.jar -Dprofile.properties=[DIR2]\profile.properties
			</code></pre>
			where [DIR] is the directory that contains the profile.jar
			<br>
			<blockquote>
			<I>Note: Due to a bug in the JDK on OS X,</I> [DIR]
			<i>must be a fully qualifed path.</i>
			</blockquote>	
			and [DIR2] is the directory that contains the profile.properties
		</p>
		<p>
			By default (if you don't give a <code>-Dprofile.properties</code>),
			profiling starts out turned on and the remote 
			interface (use to profile interactively) is turned off (see
			the <code>profile.properies</code> for more information). In 
			this case JIP works just like <code>hprof</code>, although it is
			much faster.
		</p>
		<p>
			When using with stock Tomcat, set the java agent by using the 
			env. variable <code>JAVA_OPTS</code>. For example, on Windows&#153
			use the following:
<pre><code>SET JAVA_OPTS=-javaagent:[DIR]\profile.jar -Dprofile.properties=[DIR2]\profile.properties</code></pre>			
			Where [DIR1] and [DIR2] are described as above.
		</p>
		<h3>Interactive profiling</h3>		
		<p>
			In some cases, like webapps, you probably want to start out with
			the profiler turned off. When you get to some case you want to 
			test, you'd like to turn it on, run the test case, turn the
			profiler off and dump the results. To do these things, you
			first of all need to change the profile properties file:
			<pre><code>
profiler=off
remote=on
port=15599
			</code></pre>
			To interact with the profiler you need the <code>client.jar</code> which is
			in the <code>/client</code> directory of the JIP distribution.
			<ul>
				<li>Specify the file to dump to profile data to:
<pre><code>File.bat localhost 15599 c:\tmp\test-profile.txt</code></pre>
				</li>
				<li>To turn the profiler on:
<pre><code>Start.bat localhost 15599</code></pre>
				</li>
				<li>Now you'd run your test case. When you're done,
					you can dump the profile data with:
<pre><code>Finish.bat localhost 15599</code></pre>
				</li>
			</ul>
			In my personal experience with webapps, you should exercise a
			test case at least six times before trying to measure performance.
			Presumably this is because the Just In Time compiler will observe
			how the code is used a number of times before compiling it into
			native code.
		</p>

		<h3>Examples</h3>
		There are some examples of how to use JIP: <code>example.bat</code>, 
		<code>example-ant-1.5.sh</code> and <code>example.sh</code>. All use the
		example of compiling JIP with ant. <code>example.bat</code> and 
		<code>example-ant-1.5.sh</code> work only with ant 1.5 and <code>example.sh</code>
		works only with ant 1.6 (this is because the way that ant gets invoked
		changed between the two releases).
		
		<h3>Download</h3>
		JIP can be downloaded from 
		<a href="http://sourceforge.net/projects/jiprof/">
		SourceForge.</a>
	<p/>		
	<hr/>
		<center>Copyright 2006</center>	
		<br/>			
	</body>
</html>